<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Comprehensive Python Notes</title>
  <style>
    body { font-family: Arial, sans-serif; line-height: 1.6; margin: 20px; }
    h1, h2, h3 { color: #2C3E50; }
    pre { background: #f4f4f4; border: 1px solid #ccc; padding: 10px; overflow-x: auto; }
    code { background: #f4f4f4; padding: 2px 4px; }
    .section { margin-bottom: 30px; }
    .analogy { background: #e7f3fe; border-left: 4px solid #2196F3; padding: 10px; margin: 10px 0; }
    .example { background: #f9f9f9; border: 1px solid #ddd; padding: 10px; margin: 10px 0; }
  </style>
</head>
<body>
  <h1>Comprehensive Python Notes</h1>
  <p>This document provides in-depth notes on various Python concepts ranging from basic data types and operators to advanced topics such as sorting algorithms and file handling. Each section includes clear explanations, analogies where applicable, and code examples to help illustrate the concepts.</p>

  <!-- Section: Python Data Types -->
  <div class="section" id="data-types">
    <h2>1. Python Data Types and Their Functions</h2>
    <p>Python supports various built-in data types which can be broadly classified into:</p>
    <ul>
      <li><strong>Numeric Types:</strong> <code>int</code>, <code>float</code>, <code>complex</code></li>
      <li><strong>Sequence Types:</strong> <code>list</code>, <code>tuple</code>, <code>range</code></li>
      <li><strong>Text Type:</strong> <code>str</code></li>
      <li><strong>Mapping Type:</strong> <code>dict</code></li>
      <li><strong>Set Types:</strong> <code>set</code>, <code>frozenset</code></li>
      <li><strong>Boolean Type:</strong> <code>bool</code></li>
      <li><strong>Binary Types:</strong> <code>bytes</code>, <code>bytearray</code>, <code>memoryview</code></li>
    </ul>
    <h3>Functions/Methods Associated with Data Types</h3>
    <ul>
      <li><code>int()</code>: Converts a number or string to an integer.</li>
      <li><code>float()</code>: Converts a number or string to a floating-point number.</li>
      <li><code>str()</code>: Converts an object to a string format.</li>
      <li><code>len()</code>: Returns the length (number of items) of an object.</li>
      <li><code>list()</code>: Creates a list from an iterable.</li>
      <li><code>dict()</code>: Creates a dictionary.</li>
      <li>For strings: Methods like <code>.upper()</code>, <code>.lower()</code>, <code>.split()</code>, and <code>.replace()</code> help in text manipulations.</li>
    </ul>
    <p>Understanding these data types and their associated methods is fundamental for solving various programming tasks in Python.</p>
  </div>

  <!-- Section: Operators -->
  <div class="section" id="operators">
    <h2>2. Operators in Python</h2>
    
    <h3>2.1 Logical Operators</h3>
    <p>Logical operators are used to combine conditional statements:</p>
    <ul>
      <li><code>and</code> – Returns <code>True</code> if both operands are true.</li>
      <li><code>or</code> – Returns <code>True</code> if at least one operand is true.</li>
      <li><code>not</code> – Returns <code>True</code> if the operand is false.</li>
    </ul>
    <div class="example">
      <pre>
a = True
b = False
print(a and b)  # False
print(a or b)   # True
print(not a)    # False
      </pre>
    </div>

    <h3>2.2 Comparison Operators</h3>
    <p>Comparison operators compare values and return a Boolean result:</p>
    <ul>
      <li><code>==</code>: Equal to</li>
      <li><code>!=</code>: Not equal to</li>
      <li><code>&gt;</code>: Greater than</li>
      <li><code>&lt;</code>: Less than</li>
      <li><code>&gt;=</code>: Greater than or equal to</li>
      <li><code>&lt;=</code>: Less than or equal to</li>
    </ul>
    <div class="example">
      <pre>
x = 10
y = 20
print(x == y)  # False
print(x != y)  # True
print(x &lt; y)  # True
      </pre>
    </div>

    <h3>2.3 Arithmetic Operators</h3>
    <p>Arithmetic operators are used to perform mathematical operations:</p>
    <ul>
      <li><code>+</code> : Addition</li>
      <li><code>-</code> : Subtraction</li>
      <li><code>*</code> : Multiplication</li>
      <li><code>/</code> : Division (always returns a float)</li>
      <li><code>//</code> : Floor division (returns an integer quotient)</li>
      <li><code>%</code> : Modulus (remainder of a division)</li>
      <li><code>**</code> : Exponentiation</li>
    </ul>
    <h4>Advanced Usage and Data Type Operations</h4>
    <p>Arithmetic operators can also be applied to various data types:</p>
    <ul>
      <li><strong>Strings:</strong> The <code>+</code> operator concatenates strings and <code>*</code> operator replicates them.</li>
      <li><strong>Lists/Tuples:</strong> Similar concatenation and replication operations apply to lists and tuples.</li>
    </ul>
    <div class="example">
      <pre>
# Numbers
a = 5
b = 3
print(a + b)    # 8
print(a ** b)   # 125

# Strings
s = "Hello"
print(s + " World")   # "Hello World"
print(s * 3)          # "HelloHelloHello"

# Lists
lst = [1, 2, 3]
print(lst + [4, 5])   # [1, 2, 3, 4, 5]
print(lst * 2)        # [1, 2, 3, 1, 2, 3]
      </pre>
    </div>
  </div>

  <!-- Section: Control Structures -->
  <div class="section" id="control-structures">
    <h2>3. Control Structures in Python</h2>

    <h3>3.1 If-Elif-Else Statement with Analogy</h3>
    <p>Conditional statements allow you to execute code based on conditions. The <code>if</code>-<code>elif</code>-<code>else</code> structure is akin to making decisions in everyday life. Imagine you’re deciding what to wear:</p>
    <div class="analogy">
      <p>
        <strong>If:</strong> "If it is raining, then I take an umbrella." <br>
        <strong>Elif:</strong> "Else, if it is cold, then I wear a jacket." <br>
        <strong>Else:</strong> "Otherwise, I just wear my regular clothes." 
      </p>
    </div>
    <div class="example">
      <pre>
weather = "rainy"
if weather == "rainy":
    print("Take an umbrella.")
elif weather == "cold":
    print("Wear a jacket.")
else:
    print("Wear your regular clothes.")
      </pre>
    </div>

    <h3>3.2 For Loop</h3>
    <p>For loops are used for iterating over sequences (like lists, tuples, strings, etc.).</p>
    <div class="example">
      <pre>
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print(fruit)
      </pre>
    </div>

    <h3>3.3 While Loop</h3>
    <p>A while loop repeatedly executes as long as a given condition is true.</p>
    <div class="example">
      <pre>
count = 0
while count &lt; 5:
    print("Count is:", count)
    count += 1
      </pre>
    </div>

    <h3>3.4 Break Statement</h3>
    <p>The <code>break</code> statement terminates the loop immediately when a specified condition is met.</p>
    <div class="example">
      <pre>
for num in range(10):
    if num == 5:
        break
    print(num)
      </pre>
    </div>

    <h3>3.5 Continue Statement</h3>
    <p>The <code>continue</code> statement skips the rest of the code inside the loop for the current iteration only.</p>
    <div class="example">
      <pre>
for num in range(5):
    if num == 2:
        continue
    print(num)
      </pre>
    </div>

    <h3>3.6 Pass Statement</h3>
    <p>The <code>pass</code> statement is a null operation—it is used as a placeholder in contexts where a statement is syntactically required but no action is needed.</p>
    <div class="example">
      <pre>
def placeholder_function():
    pass  # To be implemented in future

for i in range(3):
    if i == 1:
        pass  # Do nothing on i equals 1
    else:
        print(i)
      </pre>
    </div>
  </div>

  <!-- Section: Comprehensions -->
  <div class="section" id="comprehensions">
    <h2>4. Comprehensions in Python</h2>
    <h3>4.1 List Comprehension</h3>
    <p>List comprehensions provide a concise way to create lists. The syntax is:</p>
    <pre><code>[expression for item in iterable if condition]</code></pre>
    <div class="example">
      <pre>
# Example: Squaring numbers in a list
nums = [1, 2, 3, 4]
squares = [x**2 for x in nums]
print(squares)  # Output: [1, 4, 9, 16]
      </pre>
    </div>

    <h3>4.2 Dictionary Comprehension</h3>
    <p>Dictionary comprehensions allow you to create dictionaries in a similar manner:</p>
    <pre><code>{key: value for item in iterable if condition}</code></pre>
    <div class="example">
      <pre>
# Example: Creating a dictionary where key is the number and value is its square
nums = [1, 2, 3, 4]
square_dict = {x: x**2 for x in nums}
print(square_dict)  # Output: {1: 1, 2: 4, 3: 9, 4: 16}
      </pre>
    </div>
  </div>

  <!-- Section: Functions and Recursion -->
  <div class="section" id="functions">
    <h2>5. Functions, Recursion, and Related Concepts</h2>
    
    <h3>5.1 Defining a Function</h3>
    <p>Functions encapsulate reusable pieces of code. They are defined using the <code>def</code> keyword:</p>
    <div class="example">
      <pre>
def greet(name):
    """
    This function greets the person passed in as parameter.
    """
    print(f"Hello, {name}!")
    
greet("Alice")
      </pre>
    </div>

    <h3>5.2 Return Statement</h3>
    <p>The <code>return</code> statement allows a function to send a result back to the caller:</p>
    <div class="example">
      <pre>
def add(a, b):
    return a + b
    
result = add(5, 3)
print(result)  # 8
      </pre>
    </div>

    <h3>5.3 Recursion</h3>
    <p>Recursion is a process where a function calls itself. It's useful for solving problems that can be broken down into smaller, similar sub-problems.</p>
    <div class="example">
      <pre>
def factorial(n):
    # Base case: if n is 0 or 1, return 1
    if n in (0, 1):
        return 1
    # Recursive call
    return n * factorial(n - 1)

print(factorial(5))  # Output: 120
      </pre>
    </div>

    <h3>5.4 Lambda Functions</h3>
    <p>Lambda functions are small anonymous functions defined with the <code>lambda</code> keyword. They are useful for simple operations where a formal function is not required.</p>
    <div class="example">
      <pre>
# A lambda function to add two numbers
add = lambda x, y: x + y
print(add(2, 3))  # Output: 5
      </pre>
    </div>

    <h3>5.5 Fibonacci Series</h3>
    <p>The Fibonacci series is a sequence where each number is the sum of the two preceding ones. Here’s an example using recursion:</p>
    <div class="example">
      <pre>
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

# Print Fibonacci series up to 10 numbers
for i in range(10):
    print(fibonacci(i), end=" ")
      </pre>
    </div>

    <h3>5.6 *args and **kwargs</h3>
    <p>*args and **kwargs allow functions to accept an arbitrary number of arguments:</p>
    <ul>
      <li><code>*args</code> collects extra positional arguments as a tuple.</li>
      <li><code>**kwargs</code> collects extra keyword arguments as a dictionary.</li>
    </ul>
    <div class="example">
      <pre>
def flexible_function(*args, **kwargs):
    print("Positional arguments:", args)
    print("Keyword arguments:", kwargs)

flexible_function(1, 2, 3, name="Alice", age=30)
      </pre>
    </div>
  </div>

  <!-- Section: Module Importing and File Handling -->
  <div class="section" id="modules-files">
    <h2>6. Importing Modules and File Handling</h2>
    <h3>6.1 Importing Modules</h3>
    <p>You can import modules to use functions, classes, and variables defined in other files or libraries. Common ways to import include:</p>
    <ul>
      <li><code>import module_name</code></li>
      <li><code>from module_name import specific_function</code></li>
      <li><code>import module_name as alias</code></li>
    </ul>
    <div class="example">
      <pre>
import math
print(math.sqrt(16))  # Outputs 4.0
      </pre>
    </div>

    <h3>6.2 File Handling and Corner Cases</h3>
    <p>Python provides built-in functions to work with files, such as <code>open()</code> to read and write. Here are the basics and some corner cases:</p>
    <ul>
      <li>Always close a file after use. Best practice: use the <code>with</code> statement to handle files automatically.</li>
      <li>Handle exceptions (such as <code>FileNotFoundError</code> or <code>IOError</code>) to make your program robust.</li>
      <li>Be cautious with file modes: <code>'r'</code> (read), <code>'w'</code> (write/truncate), <code>'a'</code> (append), and <code>'b'</code> (binary).</li>
    </ul>
    <div class="example">
      <pre>
# Writing to a file with exception handling
try:
    with open("example.txt", "w") as file:
        file.write("Hello, file handling!")
except IOError as e:
    print("An error occurred while handling the file:", e)
      </pre>
    </div>
  </div>

  <!-- Section: Sorting Techniques -->
  <div class="section" id="sorting">
    <h2>7. Sorting Techniques and Their Workflow</h2>
    <p>Sorting is a fundamental operation and there are various techniques available. Each sorting algorithm has its own time complexity, advantages, and disadvantages:</p>
    
    <h3>7.1 Bubble Sort</h3>
    <p><strong>Workflow:</strong> Repeatedly compare adjacent elements and swap them if they are in the wrong order. This process is repeated until no swaps are needed.</p>
    <p><strong>Time Complexity:</strong> O(n<sup>2</sup>) in the worst and average case.</p>
    <div class="example">
      <pre>
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        # Last i elements are already sorted
        for j in range(0, n - i - 1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr
      </pre>
    </div>

    <h3>7.2 Insertion Sort</h3>
    <p><strong>Workflow:</strong> Build the final sorted array one item at a time, placing each new element into its appropriate position within the sorted portion.</p>
    <p><strong>Time Complexity:</strong> O(n<sup>2</sup>) worst-case, O(n) best-case (when the list is already sorted).</p>
    <div class="example">
      <pre>
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >=0 and key &lt; arr[j] :
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key
    return arr
      </pre>
    </div>

    <h3>7.3 Selection Sort</h3>
    <p><strong>Workflow:</strong> Repeatedly find the minimum element from the unsorted part and move it to the beginning.</p>
    <p><strong>Time Complexity:</strong> O(n<sup>2</sup>) for all cases.</p>
    <div class="example">
      <pre>
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if arr[j] &lt; arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr
      </pre>
    </div>

    <h3>7.4 Merge Sort</h3>
    <p><strong>Workflow:</strong> A divide and conquer algorithm that splits the array into halves, sorts each half, and then merges the sorted halves back together.</p>
    <p><strong>Time Complexity:</strong> O(n log n) for all cases.</p>
    <div class="example">
      <pre>
def merge_sort(arr):
    if len(arr) &lt;= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i &lt; len(left) and j &lt; len(right):
        if left[i] &lt; right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result
      </pre>
    </div>

    <h3>7.5 Quick Sort</h3>
    <p><strong>Workflow:</strong> Another divide and conquer algorithm that selects a 'pivot', partitions the array around the pivot, and recursively sorts the partitions.</p>
    <p><strong>Time Complexity:</strong> Average-case O(n log n), worst-case O(n<sup>2</sup>) (mitigated by good pivot selection).</p>
    <div class="example">
      <pre>
def quick_sort(arr):
    if len(arr) &lt;= 1:
        return arr
    pivot = arr[len(arr) // 2]
    left = [x for x in arr if x &lt; pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x &gt; pivot]
    return quick_sort(left) + middle + quick_sort(right)

# Example usage:
print(quick_sort([3, 6, 8, 10, 1, 2, 1]))
      </pre>
    </div>

    <h3>When to Use Which Sorting Algorithm?</h3>
    <ul>
      <li><strong>Bubble, Insertion, and Selection Sorts:</strong> Simple to implement and understand; suitable for small datasets or nearly sorted arrays. Insertion sort is particularly efficient for nearly sorted data.</li>
      <li><strong>Merge Sort and Quick Sort:</strong> Better for larger datasets. Merge sort provides stable O(n log n) performance and is optimal for linked lists or external sorting. Quick sort is often preferred for arrays due to its in-place sorting; however, care must be taken to avoid worst-case performance.</li>
    </ul>
  </div>

  <!-- Section: Conclusion -->
  <div class="section" id="conclusion">
    <h2>Conclusion</h2>
    <p>These detailed notes cover various fundamental and advanced topics in Python, including data types, operators, control flow, comprehensions, function definitions, recursion, modules, lambda expressions, file handling, and sorting techniques. Understanding these concepts is crucial for effective programming and algorithm design in Python.</p>
    <p>Feel free to refer back to these notes as you practice coding in Python and build more complex applications.</p>
  </div>
</body>
</html>
